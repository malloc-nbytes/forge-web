<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2025-07-16 Wed 14:10 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Forge (your system)</title>
<meta name="author" content="malloc-nbytes" />
<meta name="generator" content="Org Mode" />
<style type="text/css">
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Forge (your system)</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org4d37ff0">1. About</a></li>
<li><a href="#org47cd03c">2. Compiling</a></li>
<li><a href="#org4347d46">3. Getting Started</a>
<ul>
<li><a href="#orge90fede">3.1. Walkthrough adding a new project</a></li>
</ul>
</li>
<li><a href="#org5e18d85">4. Configuring <code>Forge</code></a></li>
<li><a href="#org617243a">5. API Reference</a>
<ul>
<li><a href="#org51b12cc">5.1. <code>forge/smap.h</code></a></li>
<li><a href="#org66164f6">5.2. <code>forge/arg.h</code></a></li>
<li><a href="#org7cd393f">5.3. <code>forge/rdln.h</code></a></li>
<li><a href="#orgf664a41">5.4. <code>forge/forge.h</code></a></li>
<li><a href="#org7fd2e2b">5.5. <code>forge/pkg.h</code></a></li>
<li><a href="#org0fb4f11">5.6. <code>forge/io.h</code></a></li>
<li><a href="#org5de112d">5.7. <code>forge/str.h</code></a></li>
<li><a href="#orgb729a57">5.8. <code>forge/cmd.h</code></a></li>
<li><a href="#org11f8ff0">5.9. <code>forge/colors.h</code></a></li>
<li><a href="#org648d3a6">5.10. <code>forge/mem.h</code></a></li>
<li><a href="#orgcff19a2">5.11. <code>forge/array.h</code></a></li>
<li><a href="#org018d7cb">5.12. <code>forge/ctrl.h</code></a></li>
<li><a href="#org0734417">5.13. <code>forge/viewer.h</code></a></li>
<li><a href="#orgb0b7012">5.14. <code>forge/conf.h</code></a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org4d37ff0" class="outline-2">
<h2 id="org4d37ff0"><span class="section-number-2">1.</span> About</h2>
<div class="outline-text-2" id="text-1">
<p>
Forge is a package manager where you "forge" your own packages in the form of C source files.
Every package that you want to install must have an associated C file that contains rules and functions on how to build, install, uninstall, etc.
To help with this, a suite of functions and data structures are supplied as the forge API.
</p>
</div>
</div>
<div id="outline-container-org47cd03c" class="outline-2">
<h2 id="org47cd03c"><span class="section-number-2">2.</span> Compiling</h2>
<div class="outline-text-2" id="text-2">
<p>
Forge requires sqlite3. You must either download and untar it yourself, or just run <code>./bootstrap.sh</code>.
Once this is done, run the following:
</p>

<div class="org-src-container">
<pre class="src src-bash">autoreconf --install
./configure --prefix=&lt;prefix&gt; --libdir=&lt;dir&gt;
make
</pre>
</div>

<ul class="org-ul">
<li>Where <code>&lt;prefix&gt;</code> is your preferred installation prefix for the binary i.e., <code>/usr</code>, <code>/usr/local</code>.</li>
<li>Where <code>&lt;libdir&gt;</code> is your preferred installation location for the forge library i.e., <code>/usr/lib64</code>, <code>/usr/local/lib</code>.</li>
</ul>

<p>
To install, run <code>sudo make install</code>. To uninstall, run <code>sudo make uninstall</code>.
</p>

<p>
Forge installs files to these locations:
</p>
<ul class="org-ul">
<li><code>&lt;prefix&gt;/forge</code> (binary)</li>
<li><code>&lt;prefix&gt;/include/forge</code> (API Headers)</li>
<li><code>&lt;dir&gt;/libforge.so</code> (forge library)</li>
<li><code>/var/lib/forge/forge.db</code> (forge database)</li>
<li><code>/var/cache/forge/sources/</code> (package sources)</li>
<li><code>/usr/src/forge/modules/</code> (C package modules)</li>
<li><code>/usr/lib/forge/modules</code> (compiled C package modules)</li>
</ul>
</div>
</div>
<div id="outline-container-org4347d46" class="outline-2">
<h2 id="org4347d46"><span class="section-number-2">3.</span> Getting Started</h2>
<div class="outline-text-2" id="text-3">
<p>
The first time you run <code>forge</code> must be as root. This sets up the database. All subsequent calls do not need it
(unless the action has an R tag, see <code>--help</code> for more information).
</p>

<p>
To begin creating a new package, run <code>sudo forge new &lt;pkg&gt;</code>. This will open an editor to start definining the
package rules and behavior. When you are finished, save and quit.
</p>

<p>
When new packages are added, they must be built with <code>sudo forge --rebuild</code>. This will compile them and show
any errors if needed.
</p>

<p>
If there are errors, you can run <code>sudo forge edit &lt;pkg&gt;</code> to start editing it again.
</p>

<p>
When all of your packages have been compiled, run <code>forge list</code> to see all available. You can then run the following to install them:
<code>sudo forge install &lt;pkg1&gt; &lt;pkg2&gt;, ..., &lt;pkgN&gt;</code>. If you want to remove them, run <code>sudo forge uninstall &lt;pkg1&gt; &lt;pkg2&gt;, ..., &lt;pkgN&gt;</code>.
If you want to update, do <code>sudo forge update &lt;pkg1&gt; &lt;pkg2&gt;, ..., &lt;pkgN&gt;</code> or have no arguments to update all of them.
</p>

<p>
You will notice that there are packages already available when doing <code>forge list</code>. These were downloaded from the <code>forge-modules</code> repository.
These cannot be edited, but can be updated by doing <code>forge --rebuild --sync</code> or <code>forge -rs</code>.
</p>
</div>
<div id="outline-container-orge90fede" class="outline-3">
<h3 id="orge90fede"><span class="section-number-3">3.1.</span> Walkthrough adding a new project</h3>
<div class="outline-text-3" id="text-3-1">
<p>
Here is an example of how to add a package.
</p>

<p>
I will add one of my packages called <code>AnimX</code>.
</p>

<p>
Start the module with `forge new malloc-nbytes@AnimX`. This will generate the following:
</p>

<div class="org-src-container">
<pre class="src src-c">#include &lt;forge/forge.h&gt;

char *deps[] = {NULL}; // Must be NULL terminated

char *getname(void) { return "author@pkg_name"; }
char *getver(void) { return "1.0.0"; }
char *getdesc(void) { return "My Description"; }
char **getdeps(void) { return deps; }
char *download(void) {
        return NULL; // should return the name of the final directory!
}
void build(void) {}
void install(void) {}
void uninstall(void) {}
int update(void) {
        return 0; // return 1 if it needs a rebuild, 0 otherwise
}
void get_changes(void) {
        // Pull in changes if update() returns 1
}

FORGE_GLOBAL pkg package = {
        .name = getname,
        .ver = getver,
        .desc = getdesc,
        .deps = NULL,
        .download = download,
        .build = build,
        .install = install,
        .uninstall = uninstall,
        .update = forge_pkg_git_update, // or define your own if not using git

        // Make this NULL to just re-download the source code
        // or define your own if not using git
        .get_changes = forge_pkg_git_pull,
};
</pre>
</div>

<p>
Start filling out the missing fields. Also fill out how to build, install, uninstall, and (optionally) update.
</p>

<div class="org-src-container">
<pre class="src src-c">#include &lt;forge/forge.h&gt;

char *getname(void) { return "malloc-nbytes@AnimX"; }
char *getver(void) { return "1.0.0"; }
char *getdesc(void) { return "Animated Wallpapers for X"; }
char *download(void) {
        // This download() function must return the name
        // of the directory that gets downloaded. The result
        // of git_clone() will return "AnimX". You could also do:
        //  char *download(void) {
        //    cmd("git clone https://www.github.com/malloc-nbytes/AnimX.git");
        //    return "AnimX";
        //  }
        return git_clone("malloc-nbytes", "AnimX");
}
void build(void) {
        cmd("autoreconf --install");
        configure("./", NULL);
        make(NULL);
}
void install(void) {
        make("install");
}
void uninstall(void) {
        make("uninstall");
}
void get_changes(void) {
        // Pull in changes if update() returns 1
}

FORGE_GLOBAL pkg package = {
        .name = getname,
        .ver = getver,
        .desc = getdesc,
        .deps = NULL,
        .download = download,
        .build = build,
        .install = install,
        .uninstall = uninstall,
        .update = forge_pkg_git_update, // using default git update

        // Make this NULL to just re-download the source code
        // or define your own if not using git
        .get_changes = forge_pkg_git_pull,
};
</pre>
</div>

<p>
I have decided to get rid of the <code>update()</code> function because, since this is a <code>git</code> repo, we can use
the <code>forge_pkg_git_update()</code> provided by <code>forge/pkg.h</code> (included by <code>forge/forge.h</code>). If you were to
create your own <code>update()</code> function, it must return <code>1</code> if it should get the new changes and rebuild,
and <code>0</code> if otherwise.
</p>

<p>
If you do not know any of the other functions that are being used i.e., <code>cmd()</code>, <code>make()</code>, <code>configure()</code>,
run <code>forge apilist</code> and then <code>forge api &lt;api_name&gt;</code> to see documentation.
</p>

<p>
Once you are done with your package, call <code>forge --rebuild # or forge -r</code> to rebuild all
<code>C</code> modules. If there are any errors, they will be reported. If you need to fix anything,
do <code>forge edit &lt;pkgname&gt;</code>.
</p>

<p>
You should now see your new package available by running <code>forge list</code>. To get rid of it, run <code>forge drop &lt;pkgname&gt;</code>.
This will create a backup and you can use <code>forge restore &lt;pkgname&gt;</code> to get it back.
</p>
</div>
</div>
</div>
<div id="outline-container-org5e18d85" class="outline-2">
<h2 id="org5e18d85"><span class="section-number-2">4.</span> Configuring <code>Forge</code></h2>
<div class="outline-text-2" id="text-4">
<p>
The configuration file is compiled with <code>forge</code>, meaning that if you need to edit it, you must also
recompile to get the changes. You can edit it by doing <code>forge editconf</code>. Once your changes are done,
do <code>forge updateforge</code> (this requires an internet connection).
</p>
</div>
</div>
<div id="outline-container-org617243a" class="outline-2">
<h2 id="org617243a"><span class="section-number-2">5.</span> API Reference</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-org51b12cc" class="outline-3">
<h3 id="org51b12cc"><span class="section-number-3">5.1.</span> <code>forge/smap.h</code></h3>
<div class="outline-text-3" id="text-5-1">
<div class="org-src-container">
<pre class="src src-c">#ifndef FORGE_SMAP_H_INCLUDED
#define FORGE_SMAP_H_INCLUDED

#include &lt;stddef.h&gt;

#define FORGE_SMAP_DEFAULT_TBL_CAPACITY 2048

typedef struct __forge_smap_node {
        char *k; // owns the string
        void *v;
        struct __forge_smap_node *n;
} __forge_smap_node;

typedef struct {
        __forge_smap_node **tbl;
        size_t len; // number of table entries
        size_t cap; // capacity of table
        size_t sz; // how many total nodes
} forge_smap;

/**
 * Returns: a new string map
 * Description: Create a new string map. Make sure to
 *              call forge_smap_destroy() to free memory.
 */
forge_smap forge_smap_create(void);

/**
 * Parameter: map -&gt; the map to insert to
 * Parameter: k   -&gt; the key
 * Parameter: v   -&gt; the value
 * Description: Insert key `k` with value `v` into the map `map`.
 */
void forge_smap_insert(forge_smap *map, const char *k, void *v);

/**
 * Parameter: map -&gt; the map to query
 * Parameter: k   -&gt; the key to check
 * Returns: 1 if found, 0 if otherwise
 * Description: See if the key `k` is inside of the map `map`.
 */
int forge_smap_contains(const forge_smap *map, const char *k);

/**
 * Parameter: map -&gt; the map to get from
 * Parameter: k   -&gt; the key with the associated value
 * Returns: the value of of the key `k`.
 * Description: Get the value that the key `k` is associated with.
 */
void *forge_smap_get(const forge_smap *map, const char *k);

/**
 * Parameter: map -&gt; the map to destroy
 * Description: free()'s all memory that `map` allocates.
 */
void forge_smap_destroy(forge_smap *map);

/**
 * Parameter: map -&gt; the map to iterate
 * Returns: an array of keys (NULL terminated, NULL on failure)
 * Description: Use this function to get all keys inside of
 *              the map. It is guaranteed to be NULL terminated.
 *              The result needs to be free()'d. The individual strings
 *              do not need to be free()'d.
 */
char **forge_smap_iter(const forge_smap *map);

/**
 * Paramter: map -&gt; the map to get the size from
 * Returns: the number of nodes in the map
 * Description: Get the number of nodes stored inside of `map`.
 */
size_t forge_smap_size(const forge_smap *map);

#endif // FORGE_SMAP_H_INCLUDED


</pre>
</div>
</div>
</div>
<div id="outline-container-org66164f6" class="outline-3">
<h3 id="org66164f6"><span class="section-number-3">5.2.</span> <code>forge/arg.h</code></h3>
<div class="outline-text-3" id="text-5-2">
<div class="org-src-container">
<pre class="src src-c">#ifndef FORGE_ARG_H_INCLUDED
#define FORGE_ARG_H_INCLUDED

#include &lt;stddef.h&gt;

typedef struct forge_arg {
        // Points to the start of the argument
        // after any hyphens (max 2).
        char *s;

        // The number of hyphens (max 2).
        size_t h;

        // Points to the character after the
        // first equals is encountered.
        char *eq;

        // The next argument
        struct forge_arg *n;
} forge_arg;

/**
 * Parameter: argc       -&gt; number of args
 * Parameter: argv       -&gt; actual args
 * Parameter: skip_first -&gt; skip the first arg
 * Returns: linked list of `forge_arg`s
 * Description: Create a list of args that you can
 *              query. The `skip_first` parameter is there
 *              if you do not want the program name to appear
 *              in the linked list. Also, you should always have
 *              a copy to the head of this list for `forge_arg_free()`.
 */
forge_arg *forge_arg_alloc(
        int    argc,
        char **argv,
        int    skip_first
);

/**
 * Parameter: arg -&gt; the pointer to the start of the arg list
 * Description: Free all memory allocated for the linked
 *              list of forge_args. This function should
 *              take the head of a linked list.
 */
void forge_arg_free(forge_arg *arg);

#endif // FORGE_ARG_H_INCLUDED


</pre>
</div>
</div>
</div>
<div id="outline-container-org7cd393f" class="outline-3">
<h3 id="org7cd393f"><span class="section-number-3">5.3.</span> <code>forge/rdln.h</code></h3>
<div class="outline-text-3" id="text-5-3">
<div class="org-src-container">
<pre class="src src-c">#ifndef FORGE_RDLN_H_INCLUDED
#define FORGE_RDLN_H_INCLUDED

char *forge_rdln(const char *prompt);

#endif // FORGE_RDLN_H_INCLUDED


</pre>
</div>
</div>
</div>
<div id="outline-container-orgf664a41" class="outline-3">
<h3 id="orgf664a41"><span class="section-number-3">5.4.</span> <code>forge/forge.h</code></h3>
<div class="outline-text-3" id="text-5-4">
<div class="org-src-container">
<pre class="src src-c">#ifndef FORGE_FORGE_H_INCLUDED
#define FORGE_FORGE_H_INCLUDED

#include "forge/pkg.h"
#include "forge/cmd.h"
#include "forge/str.h"
#include "forge/array.h"
#include "forge/io.h"
#include "forge/smap.h"
#include "forge/viewer.h"
#include "forge/colors.h"
#include "forge/mem.h"
#include "forge/ctrl.h"
#include "forge/rdln.h"
#include "forge/arg.h"
#include "forge/conf.h"

/**
 * This file is solely used for including all
 * API headers. Nothing else should be added here!
 */

#endif // FORGE_FORGE_H_INCLUDED


</pre>
</div>
</div>
</div>
<div id="outline-container-org7fd2e2b" class="outline-3">
<h3 id="org7fd2e2b"><span class="section-number-3">5.5.</span> <code>forge/pkg.h</code></h3>
<div class="outline-text-3" id="text-5-5">
<div class="org-src-container">
<pre class="src src-c">#ifndef FORGE_PKG_H_INCLUDED
#define FORGE_PKG_H_INCLUDED

#include &lt;stddef.h&gt;

#define FORGE_GLOBAL __attribute__((visibility("default")))

typedef struct {
        char *(*name)(void);
        char *(*ver)(void);
        char *(*desc)(void);
        char **(*deps)(void);
        char *(*download)(void);
        void (*build)(void);
        void (*install)(void);
        void (*uninstall)(void);
        int (*update)(void);
        void (*get_changes)(void);
} pkg;

/**
 * Returns: 1 if it should re-download the package,
 *          or 0 if it shouldn't.
 * Description: Performs the built-in way of doing
 *              an update if the package uses git.
 */
int forge_pkg_git_update(void);

/**
 * Description: Performs the built-in way of pulling
 *              changes if a package uses git.
 */
void forge_pkg_git_pull(void);

/**
 * Description: Used in the .update part of the pkg struct.
 *              Use this if you want to notify that updates
 *              need manual checking.
 */
#define forge_pkg_update_manual_check NULL

/**
 * Description: Used in the .get_changes part of the pkg struct.
 *              Use this if you want to completely redownload
 *              the source code to get the new changes.
 */
#define forge_pkg_get_changes_redownload NULL

#endif // FORGE_PKG_H_INCLUDED


</pre>
</div>
</div>
</div>
<div id="outline-container-org0fb4f11" class="outline-3">
<h3 id="org0fb4f11"><span class="section-number-3">5.6.</span> <code>forge/io.h</code></h3>
<div class="outline-text-3" id="text-5-6">
<div class="org-src-container">
<pre class="src src-c">#ifndef FORGE_IO_H_INCLUDED
#define FORGE_IO_H_INCLUDED

/**
 * Parameter: fp -&gt; the filepath
 * Returns: 1 if exists, 0 if not exists
 * Description: Checks if the filepath `fp` exists.
 */
int forge_io_filepath_exists(const char *fp);

/**
 * Parameter: fp              -&gt; the filepath
 * Parameter: force_overwrite -&gt; should we overwrite the file
 *                               even if it exists?
 * Description: Create a file at `fp`. If `force_overwrite` is
 *              set to 1, it will truncate the file if it exists.
 */
void forge_io_create_file(const char *fp, int force_overwrite);

/**
 * Parameter: fp -&gt; the filepath
 * Returns: the bytes of the file
 * Description: Read all bytes at the filepath `fp`.
 */
char *forge_io_read_file_to_cstr(const char *fp);

/**
 * Parameter: fp -&gt; the filepath
 * Returns: lines of the file, end of the array is guaranteed
 *          to be NULL.
 * Description: Read all lines at the filepath `fp`.
 */
char **forge_io_read_file_to_lines(const char *fp);

/**
 * Parameter: fp -&gt; the filepath
 * Returns: the absolute filepath of `fp`
 * Description: Get the absolute path of `fp`.
 */
char *forge_io_resolve_absolute_path(const char *fp);

/**
 * Parameter: fp      -&gt; the filepath
 * Parameter: content -&gt; the bytes to write to `fp`
 * Returns: 1 on success, 0 on failure
 * Description: Write `content` to `fp`.
 */
int forge_io_write_file(const char *fp, const char *content);

/**
 * Parameter: fp      -&gt; the filepath
 * Parameter: lines   -&gt; the lines to write
 * Parameter: lines_n -&gt; how many lines to write
 * Returns: 1 on success, 0 on failure
 * Description: Write `lines_n` lines from `lines` to the filepath `fp`.
 */
int forge_io_write_lines(
        const char *fp,
        const char **lines,
        size_t lines_n
);

/**
 * Parameter: path -&gt; the filepath to check
 * Returns: 1 if it is a directory, and 0 if not
 * Description: Check if `path` is a directory.
 */
int forge_io_is_dir(const char *path);

/**
 * Parameter: dir      -&gt; the directory to search
 * Parameter: filename -&gt; the file to search for
 * Returns: 1 if found, and 0 if otherwise
 * Description: Checks to see if `dir` contains `filename`.
 */
int forge_io_dir_contains_file(const char *dir, const char *filename);

/**
 * Parameter: path -&gt; the path to extract the basename from
 * Returns: the basename
 * Description: Given some path i.e., `/home/user/dev/main.c`,
 *              will extract the basename `main.c` from the path.
 */
const char *forge_io_basename(const char *path);

/**
 * Parameter: path -&gt; the directory to remove
 * Return: 1 on success, and 0 on failure.
 * Description: Remove the directory `path`.
 */
int forge_io_rm_dir(const char *path);

#endif // FORGE_IO_H_INCLUDED


</pre>
</div>
</div>
</div>
<div id="outline-container-org5de112d" class="outline-3">
<h3 id="org5de112d"><span class="section-number-3">5.7.</span> <code>forge/str.h</code></h3>
<div class="outline-text-3" id="text-5-7">
<div class="org-src-container">
<pre class="src src-c">#ifndef FORGE_STR_H_INCLUDED
#define FORGE_STR_H_INCLUDED

typedef struct {
        char *data;
        size_t len, cap;
} forge_str;

/**
 * Returns: an empty forge_str
 * Description: Create a new empty forge_str.
 */
forge_str forge_str_create(void);

/**
 * Parameter: s -&gt; the string to create from
 * Returns: a new forge_str created from `s`.
 * Description: Creates a new forge_str with the
 *              content of `s`.
 */
forge_str forge_str_from(const char *s);

/**
 * Parameter: s -&gt; the string to take from
 * Returns: a new forge_str created from `s`.
 * Description: Creates a new forge_str with the
 *              content of `s`. It will take ownership
 *              of the pointer so it will be destroyed
 *              in `forge_str_destroy()`.
 */
forge_str forge_str_take(char *s);

/**
 * Parameter: fs -&gt; the forge_str
 * Description: Clear the string `fs`.
 */
void forge_str_clear(forge_str *fs);

/**
 * Parameter: fs -&gt; the forge_str
 * Description: free() all memory associated with `fs`. This also
                resets all other members of `fs` so it can be re-used.
 */
void forge_str_destroy(forge_str *fs);

/**
 * Parameter: fs -&gt; the forge_str to append to
 * Parameter: c  -&gt; the character to append
 * Description: Append the character `c` to `fs`.
 */
void forge_str_append(forge_str *fs, char c);

/**
 * Parameter: fs -&gt; the forge_str to concat to
 * Parameter: s -&gt; the string to concat
 * Description: Concatinate `s` to `fs`.
 */
void forge_str_concat(forge_str *fs, const char *s);

/**
 * Paramter: s0 -&gt; the first forge_str
 * Paramter: s1 -&gt; the second forge_str
 * Returns: 1 if they are equal, and 0 if otherwise
 * Description: Check if s0 == s1.
 */
int forge_str_eq(const forge_str *s0, const forge_str *s1);

/**
 * Parameter: s0 -&gt; the forge_str
 * Parameter: s1 -&gt; the c_str
 * Returns: 1 if they are equal, and 0 if otherwise
 * Description: Checks if s0.data == s1.
 */
int forge_str_eq_cstr(const forge_str *s0, const char *s1);

/**
 * Parameter: fs -&gt; the forge_str
 * Returns: the c_str of `fs`
 * Description: Get the underlying c_str data of `fs`.
 */
char *forge_str_to_cstr(const forge_str *fs);

/**
 * Parameter: fs             -&gt; the forge_str to search in
 * Parameter: substr         -&gt; the substring to search
 * Parameter: case_sensitive -&gt; whether it should be case sensitive
 * Returns: a pointer to the start of the substring if found,
 *          or NULL if not found
 * Description: Check `fs` for substring `substr`.
 */
char *forge_str_contains_substr(
        const forge_str *fs,
        const char *substr,
        int case_sensitive
);

/**
 * Parameter: fs  -&gt; the forge_str to insert into
 * Parameter: c   -&gt; the character to insert
 * Parameter: idx -&gt; the index to insert at
 * Description: Insert character `c` into string `fs` at index `idx`.
 */
void forge_str_insert_at(forge_str *fs, char c, size_t idx);

/**
 * Parameter: first -&gt; the first string
 * VARIADIC         -&gt; other strings
 * Returns: the concatination of all strings
 * Description: Build a string of the variadic parameters.
 *              Note: Remember to put NULL as the last argument!
 */
char *forge_str_builder(const char *first, ...);

/**
 * Parameter: fs -&gt; the forge_string
 * Returns: the character that was removed
 * Description: Pop's the last character off of
 *              the string `fs`. It is up to you
 *              to make sure that `fs.len &gt; 0`.
 */
char forge_str_pop(forge_str *fs);

char forge_str_rm_at(forge_str *fs, size_t idx);

#endif // FORGE_STR_H_INCLUDED


</pre>
</div>
</div>
</div>
<div id="outline-container-orgb729a57" class="outline-3">
<h3 id="orgb729a57"><span class="section-number-3">5.8.</span> <code>forge/cmd.h</code></h3>
<div class="outline-text-3" id="text-5-8">
<div class="org-src-container">
<pre class="src src-c">#ifndef FORGE_CMD_H_INCLUDED
#define FORGE_CMD_H_INCLUDED

/**
 * Returns: the current working directory
 * Description: Gets the current working directory or NULL on failure.
 */
char *cwd(void);

/**
 * Parameter: fp -&gt; the filepath to cd into
 * Returns: 1 on success, 0 on failure
 * Description: cd into the filepath `fp`.
 */
int cd(const char *fp);

/**
 * Parameter: fp -&gt; the filepath to cd into
 * Returns: 1 on success, 0 on failure
 * Description: the same as cd(), but silent.
 */
int cd_silent(const char *fp);

/**
 * Parameter: cmd -&gt; the command to execute
 * Returns: 1 on success, 0 on failure
 * Description: Issue a BASH command.
 */
int cmd(const char *cmd);

/**
 * Parameter: cmd      -&gt; the command to execute
 * Parameter: username -&gt; the user to execute the command as
 * Returns: 1 on success, 0 on failure
 * Description: Issue a BASH command as a specific user.
 *              This is useful if the program is being ran
 *              through `sudo` and you need to create some
 *              files not in /root/. It might be useful to
 *              call get_prev_user() to get the user that
 *              ran forge through sudo.
 */
int cmd_as(const char *cmd, const char *username);

/**
 * Parameter: cmd -&gt; the command to execute
 * Returns: the output of the command, or NULL on failure
 * Description: Issue a BASH command and capture the output.
 *              If the command fails or something goes wrong,
 *              return return result will be NULL.
 */
char *cmdout(const char *cmd);

/**
 * Parameter: author -&gt; the author of the program
 * Parameter: name   -&gt; the name of the program
 * Returns: the name of the program
 * Description: Do a `git clone https://www.github.com/&lt;author&gt;/&lt;name&gt;.git`.
 *              This function returns the name of the command as it is
 *              convenient for the download() function in the C modules.
 */
char *git_clone(char *author, char *name);

/**
 * Parameter: fp -&gt; the filepath to create
 * Returns: the filepath, or NULL on failure
 * Description: Create a directory with the `-p` flag.
 */
char *mkdirp(char *fp);

/**
 * Parameter: var -&gt; the environment variable
 * Returns: the value of the environment variable, or NULL on failure
 * Description: Get the value of an environment variable. Do not
 *              include the dollarsign ($) in the variable name.
 */
char *env(const char *var);

/**
 * Returns: the username of the previous user
 * Description: Get the username of the previous user
 *              calling forge. For example, if forge was
 *              ran as: `USER@/bin/sh# sudo forge install ...`, then the
 *              result will be USER.
 */
char *get_prev_user(void);

/**
 * Parameter: path -&gt; the path to the file to change
 * Parameter: user -&gt; the user to give ownership to
 * Returns: 1 on success, or 0 on failure
 * Description: Change the ownership of `path` to `user`.
 */
int change_file_owner(const char *path, const char *user);

/**
 * Parameter: type? -&gt; the type of make we are doing
 * Returns: 1 on success, or 0 on failure
 * Description: Performs `make &lt;type&gt;` and utilizes
 * macros in conf.h. If `type` is NULL, it will just
 * call `make`.
 */
int make(const char *type);

/**
 * Parameter: flags -&gt; the flags to pass to configure
 * Parameter: fp?   -&gt; the path to configure
 * Returns: 1 on success, or 0 on failure
 * Description: Performs `&lt;fp&gt;configure &lt;flags&gt;` and utilizes
 * macros in conf.h. Make sure to include the last '/' in `fp`!
 */
int configure(const char *fp, const char *flags);

/**
 * Paramater: dir -&gt; the dir to perform `ls` on
 * Returns: an array of all files found in `dir`.
 * Description: Perform `ls` on `dir`. Collects all files
 *              found and returns them in an array. The end
 *              of the array is guaranteed to be NULL terminated.
 *              If something goes wrong, the return result will be NULL.
 *              All entries of the array must be free()'d, and the
 *              array itself must be free()'d.
 */
char **ls(const char *dir);

/**
 * Paramter: path -&gt; the path to check
 * Returns: 1 if `path` is a git directory, and 0 if otherwise
 * Description: Check if `path` is a git directory.
 */
int is_git_dir(const char *path);

#endif // FORGE_CMD_H_INCLUDED


</pre>
</div>
</div>
</div>
<div id="outline-container-org11f8ff0" class="outline-3">
<h3 id="org11f8ff0"><span class="section-number-3">5.9.</span> <code>forge/colors.h</code></h3>
<div class="outline-text-3" id="text-5-9">
<div class="org-src-container">
<pre class="src src-c">#ifndef FORGE_COLORS_H_INCLUDED
#define FORGE_COLORS_H_INCLUDED

#define YELLOW               "\033[93m"
#define GREEN                "\033[32m"
#define BRIGHT_GREEN         "\033[92m"
#define GRAY                 "\033[90m"
#define RED                  "\033[31m"
#define BLUE                 "\033[94m"
#define CYAN                 "\033[96m"
#define MAGENTA              "\033[95m"
#define WHITE                "\033[97m"
#define BLACK                "\033[30m"
#define CYAN                 "\033[96m"
#define PINK                 "\033[95m"
#define BRIGHT_PINK          "\033[38;5;213m"
#define PURPLE               "\033[35m"
#define BRIGHT_PURPLE        "\033[95m"
#define ORANGE               "\033[38;5;214m"
#define BROWN                "\033[38;5;94m"

#define UNDERLINE            "\033[4m"
#define BOLD                 "\033[1m"
#define ITALIC               "\033[3m"
#define DIM                  "\033[2m"
#define INVERT               "\033[7m"
#define RESET                "\033[0m"

char *forge_colors_c_to_string(const char *s);

#endif // FORGE_COLORS_H_INCLUDED


</pre>
</div>
</div>
</div>
<div id="outline-container-org648d3a6" class="outline-3">
<h3 id="org648d3a6"><span class="section-number-3">5.10.</span> <code>forge/mem.h</code></h3>
<div class="outline-text-3" id="text-5-10">
<div class="org-src-container">
<pre class="src src-c">#ifndef FORGE_MEM_H_INCLUDED
#define FORGE_MEM_H_INCLUDED

#include &lt;stdint.h&gt;

void *forge_mem_malloc(size_t nbytes);

#endif // FORGE_MEM_H_INCLUDED


</pre>
</div>
</div>
</div>
<div id="outline-container-orgcff19a2" class="outline-3">
<h3 id="orgcff19a2"><span class="section-number-3">5.11.</span> <code>forge/array.h</code></h3>
<div class="outline-text-3" id="text-5-11">
<div class="org-src-container">
<pre class="src src-c">#ifndef FORGE_ARRAY_H_INCLUDED
#define FORGE_ARRAY_H_INCLUDED

#include &lt;stdlib.h&gt;





/* This file is used for making stack alloc'd dynamic
 * arrays where we dont need to use the Array&lt;T&gt; DS. */

/**
 * Creates a new dynamic array type globally.
 * Note: Use dyn_array_init() to initialize
 *       any instances of it.
 * Example:
 *   dyn_array_type(int, Int_Array);
 *
 *   void f(Int_Array *arr);
 *
 *   int main(void) {
 *       Int_Array arr;
 *       return 0;
 *   }
 */
#define DYN_ARRAY_TYPE(ty, name) \
    typedef struct {             \
        ty *data;                \
        size_t len, cap;         \
    } name

#define dyn_array_empty(arr_ty)                 \
        (arr_ty) {                              \
                .data = NULL,                   \
                .len = 0,                       \
                .cap = 0,                       \
        }

/**
 * Initializes a global array type. This is only
 * used if you use DYN_ARRAY_TYPE().
 * Example:
 *   dyn_array_type(int, Int_Array);
 *
 *   int main(void) {
 *       Int_Array arr;
 *       dyn_array_init_type(arr); // &lt;- here
 *       return 0;
 *   }
 */
#define dyn_array_init_type(da)                 \
    do {                                        \
        (da).data = malloc(sizeof(*(da).data)); \
        (da).cap = 1;                           \
        (da).len = 0;                           \
    } while (0)

/**
 * Creates a new dynamic array on the stack.
 * Example:
 *   dyn_array(int, int_vector);
 */
#define dyn_array(ty, name)                                        \
    struct {                                                       \
        ty *data;                                                  \
        size_t len, cap;                                           \
    } (name) = { .data = (typeof(ty) *)malloc(sizeof(ty)), .len = 0, .cap = 1 };

/**
 * Append to a dynamic array.
 * Example:
 *   dyn_array(int, int_vector);
 *   for (int i = 0; i &lt; 10; ++i)
 *     dyn_array_append(int_vector, i);
 */
#define dyn_array_append(da, value)                                     \
    do {                                                                \
        if ((da).len &gt;= (da).cap) {                                     \
            (da).cap = (da).cap ? (da).cap * 2 : 2;                     \
            (da).data = (typeof(*((da).data)) *)                        \
                realloc((da).data,                                      \
                        (da).cap * sizeof(*((da).data)));               \
        }                                                               \
        (da).data[(da).len++] = (value);                                \
    } while (0)

/**
 * Free a dynamic array.
 * Example:
 *   dyn_array(int, int_vector);
 *   dyn_array_free(int_vector);
*/
#define dyn_array_free(da)       \
    do {                         \
        if ((da).data != NULL) { \
                free((da).data); \
        }                        \
        (da).len = (da).cap = 0; \
    } while (0)

/**
 * Get an element safely at an index.
 * Will panic if the element is out of bounds.
 * Example:
 *   dyn_array(int, int_vector);
 *   dyn_array_append(int_vector, i);
 *   printf("%d\n", dyn_array_at_s(int_vector));
 */
#define dyn_array_at_s(da, i)                                      \
    ((i) &lt; (da).len ? (da).data[i] : (fprintf(stderr,              \
    "[dyn_array error]: index %zu is out of bounds (len = %zu)\n", \
    (size_t)(i), (size_t)(da).len), exit(1), (da).data[0]))

/**
 * Get an element at an index.
 * Example:
 *   dyn_array(int, int_vector);
 *   dyn_array_append(int_vector, i);
 *   printf("%d\n", dyn_array_at(int_vector));
 */
#define dyn_array_at(da, i) ((da).data[i])

/**
 * Clear a dynamic array.
 * Example:
 *   dyn_array(int, int_vector);
 *   dyn_array_append(int_vector, i);
 *   dyn_array_clear(int_vector);
 */
#define dyn_array_clear(da) (da).len = 0;

/**
 * Remove an element at index `idx`.
 * Example:
 *   dyn_array(int, int_vector);
 *   ...
 *   dyn_array_rm_at(int_vector, 0);
 *   dyn_array_rm_at(int_vector, 5);
 *   ...
 */
#define dyn_array_rm_at(da, idx) \
    do {                                                     \
        for (size_t __i_ = (idx); __i_ &lt; (da).len-1; ++__i_) \
            (da).data[__i_] = (da).data[__i_+1];             \
        (da).len--;                                          \
    } while (0)

#define dyn_array_explode(da) (da).data, (da).len, (da).cap

#define dyn_array_explode_mem(da) &amp;(da).data, &amp;(da).len, &amp;(da).cap


DYN_ARRAY_TYPE(int,      int_array);
DYN_ARRAY_TYPE(char,     char_array);
DYN_ARRAY_TYPE(char *,   str_array);
DYN_ARRAY_TYPE(size_t,   size_t_array);
DYN_ARRAY_TYPE(float,    float_array);
DYN_ARRAY_TYPE(double,   double_array);
DYN_ARRAY_TYPE(long,     long_array);
DYN_ARRAY_TYPE(unsigned, unsigned_array);
DYN_ARRAY_TYPE(void *,   void_ptr_array);

#endif // FORGE_ARRAY_H_INCLUDED


</pre>
</div>
</div>
</div>
<div id="outline-container-org018d7cb" class="outline-3">
<h3 id="org018d7cb"><span class="section-number-3">5.12.</span> <code>forge/ctrl.h</code></h3>
<div class="outline-text-3" id="text-5-12">
<div class="org-src-container">
<pre class="src src-c">#ifndef FORGE_CTRL_H_INCLUDED
#define FORGE_CTRL_H_INCLUDED

#include &lt;termios.h&gt;

#define CTRL_A 1
#define CTRL_B 2
#define CTRL_C 3
#define CTRL_D 4
#define CTRL_E 5
#define CTRL_F 6
#define CTRL_G 7
#define CTRL_H 8
#define CTRL_I 9
#define CTRL_J 10
#define CTRL_K 11
#define CTRL_L 12
#define CTRL_M 13
#define CTRL_N 14
#define CTRL_O 15
#define CTRL_P 16
#define CTRL_Q 17
#define CTRL_R 18
#define CTRL_S 19
#define CTRL_T 20
#define CTRL_U 21
#define CTRL_V 22
#define CTRL_W 23
#define CTRL_X 24
#define CTRL_Y 25
#define CTRL_Z 26

#define UP_ARROW    'A'
#define DOWN_ARROW  'B'
#define RIGHT_ARROW 'C'
#define LEFT_ARROW  'D'

/**
 * Parameter: ch -&gt; the character to compare
 * Returns: whether `ch` is a newline
 * Description: Check if `ch` is a newline.
 */
#define ENTER(ch)     ((ch) == '\n')

/**
 * Parameter: ch -&gt; the character to compare
 * Returns: whether `ch` is a backspace
 * Description: Check if `ch` is a backspace.
 */
#define BACKSPACE(ch) ((ch) == 8 || (ch) == 127)

/**
 * Parameter: ch -&gt; the character to compare
 * Returns: whether `ch` is a tab
 * Description: Check if `ch` is a tab.
 */
#define TAB(ch)       ((ch) == '\t')

/**
 * Parameter: ch -&gt; the character to compare
 * Returns: whether `ch` is an escape sequence
 * Description: Check if `ch` is an escape sequence.
 */
#define ESCSEQ(ch)    ((ch) == 27)

/**
 * Parameter: ch -&gt; the character to compare
 * Returns: whether `ch` is a control sequence
 * Description: Check if `ch` is a control sequence.
 */
#define CSI(ch)       ((ch) == '[')

#define CURSOR_LEFT(n)  printf("\033[%dD", n);
#define CURSOR_RIGHT(n) printf("\033[%dC", n);
#define CURSOR_UP(n)    printf("\033[%dA", n);
#define CURSOR_DOWN(n)  printf("\033[%dB", n);

typedef enum {
    USER_INPUT_TYPE_CTRL,
    USER_INPUT_TYPE_ALT,
    USER_INPUT_TYPE_ARROW,
    USER_INPUT_TYPE_SHIFT_ARROW,
    USER_INPUT_TYPE_NORMAL,
    USER_INPUT_TYPE_UNKNOWN,
} forge_ctrl_input_type;

/**
 * Parameter: fd          -&gt; the file descriptor
 * Parameter: old_termios -&gt; the termios to copy bits from
 * Returns: 1 on success, 0 on failure
 * Description: Enable the terminal raw mode. This disables the bits:
 *                  ECHO
 *                  ICANON
 *                  IXON.
 *              Note: If working with stdin, `fd` should be STDIN_FILENO.
 */
int forge_ctrl_enable_raw_terminal(int fd, struct termios *old_termios);

/**
 * Parameter: fd          -&gt; the file descriptor
 * Parameter: old_termios -&gt; the termios to copy bits from
 * Returns: 1 on success, 0 on failure
 * Description: Disables the terminal raw mode. The old termios
 *              should have the same memory address as the termios
 *              passed to `forge_ctrl_enable_raw_terminal()`.
 */
int forge_ctrl_disable_raw_terminal(int fd, struct termios *old_termios);

/**
 * Parameter: c -&gt; the character to store to
 * Returns: the type of input the user entered
 * Description: Will read input from the user. The type of that
 *              input will be the return type (see enum forge_ctrl_input_type)
 *              and the actual byte data will be inside of `c`.
 */
forge_ctrl_input_type forge_ctrl_get_input(char *c);

/**
 * Description: Clear the terminal.
 */
void forge_ctrl_clear_terminal(void);

/**
 * Description: Clear the current line.
 */
void forge_ctrl_clear_line(void);

/**
 * Parameter: n -&gt; the column number
 * Description: Move the cursor to column `n`.
 */
void forge_ctrl_cursor_to_col(int n);

#endif // FORGE_CTRL_H_INCLUDED


</pre>
</div>
</div>
</div>
<div id="outline-container-org0734417" class="outline-3">
<h3 id="org0734417"><span class="section-number-3">5.13.</span> <code>forge/viewer.h</code></h3>
<div class="outline-text-3" id="text-5-13">
<div class="org-src-container">
<pre class="src src-c">#ifndef FORGE_VIEWER_H_INCLUDED
#define FORGE_VIEWER_H_INCLUDED

#include &lt;termios.h&gt;

typedef struct {
        char **data;
        size_t rows;
        size_t cols;
        size_t win_width;
        size_t win_height;
        size_t height_offset;
        struct termios old_termios;

        struct {
                int mode;
                char *buffer;
                size_t len;
                size_t cap;
                // Last search query
                char *last;
        } search;

        struct {
                // array of matching row indices
                size_t *matches;
                size_t count;
                size_t cap;
                size_t current;
        } match;
} forge_viewer;

/**
 * Parameter: data   -&gt; the lines to put into the viewer
 * Parameter: data_n -&gt; the number of lines in `data`
 * Returns: a new forge_viewer
 * Description: Create a new forge_viewer of `data` (copied),
 *              `data_n` lines long. No need to free()
 *              `data`.
 */
forge_viewer *forge_viewer_alloc(char **data, size_t data_n);

/**
 * Parameter: v -&gt; the viewer
 * Description: free() all memory used by the viewer
 */
void forge_viewer_free(forge_viewer *v);

/**
 * Parameter: v -&gt; the viewer
 * Description: Display all lines in the viewer.
 *              This opens a `less`-like viewer.
 */
void forge_viewer_display(forge_viewer *v);

#endif // FORGE_VIEWER_H_INCLUDED


</pre>
</div>
</div>
</div>
<div id="outline-container-orgb0b7012" class="outline-3">
<h3 id="orgb0b7012"><span class="section-number-3">5.14.</span> <code>forge/conf.h</code></h3>
<div class="outline-text-3" id="text-5-14">
<div class="org-src-container">
<pre class="src src-c">#ifndef FORGE_CONF_H_INCLUDED
#define FORGE_CONF_H_INCLUDED

#define FORGE_PREFERRED_MAKEFILE_JFLAGS "$(nproc)"

#define FORGE_PREFERRED_INSTALL_PREFIX "/usr/local"

#define FORGE_PREFERRED_LIB_PREFIX "/usr/local/lib64"

#define FORGE_EDITOR "vim"

#endif // FORGE_CONF_H_INCLUDED


</pre>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: malloc-nbytes</p>
<p class="date">Created: 2025-07-16 Wed 14:10</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
